;;; ═══════════════════════════════════════════════════════════════
;;; SOMA ASSEMBLER — somasc v1.0
;;; The SOMA self-hosting assembler, written in SOMA itself.
;;; Reads .soma source → emits .sombin binary
;;;
;;; This IS the bootstrap: once a host runtime can execute .sombin,
;;; this file compiles itself. No other language needed.
;;; ═══════════════════════════════════════════════════════════════

.SOMA    1.0.0
.ARCH    ANY
.SOMSIZE 16x16
.AGENTS  64
.LEARNRATE 0.1
.EPOCHS  0

;;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
;;; DATA SECTION — assembler state
;;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.DATA

;;; Input / output buffers
src_buf     : BYTE[65536]          ;;; raw source text
bin_buf     : BYTE[131072]         ;;; output binary buffer
bin_ptr     : INT   = 0            ;;; write cursor

;;; Parsing state
src_ptr     : INT   = 0            ;;; read cursor
src_len     : INT   = 0            ;;; source length
line_no     : INT   = 1            ;;; current line number
tok_buf     : BYTE[256]            ;;; current token
tok_len     : INT   = 0

;;; Symbol table (label name → binary offset)
sym_count   : INT   = 0
sym_names   : BYTE[256 * 64]       ;;; 256 symbols × 64 chars
sym_addrs   : INT[256]             ;;; corresponding addresses

;;; Patch table (forward refs to fix up after first pass)
patch_count : INT   = 0
patch_locs  : INT[1024]            ;;; binary offsets needing patch
patch_names : BYTE[1024 * 64]      ;;; label names for each patch

;;; File header template
hdr_magic   : BYTE[4] = 0x53, 0x4F, 0x4D, 0x41   ;;; "SOMA"
hdr_ver     : BYTE[4] = 0x00, 0x01, 0x00, 0x00    ;;; v1.0

;;; Error message codes
ERR_UNKNOWN_OP  : INT = 0x01
ERR_BAD_REG     : INT = 0x02
ERR_NO_LABEL    : INT = 0x03
ERR_SYNTAX      : INT = 0x04
ERR_OVERFLOW    : INT = 0x05

;;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
;;; CODE SECTION
;;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.CODE

@_start:
  ;;; syscall: read source file into src_buf
  TRAP    0x01                   ;;; TRAP 1 = READ_FILE → src_len
  MOV     R0, [src_len]
  JZ      R0, @error_empty

  ;;; write .sombin header
  CALL    @emit_header

  ;;; ── PASS 1: collect labels ──────────────────────
  ZERO    R0
  STORE   [src_ptr], R0
  STORE   [sym_count], R0
  CALL    @pass_one

  ;;; ── PASS 2: emit binary ─────────────────────────
  ZERO    R0
  STORE   [src_ptr], R0
  CALL    @pass_two

  ;;; resolve forward references (patch table)
  CALL    @patch_resolve

  ;;; flush binary to output file
  TRAP    0x02                   ;;; TRAP 2 = WRITE_FILE

  HALT

;;; ─────────────────────────────────────────────────
;;; EMIT HEADER
;;; Writes the 32-byte .sombin file header
;;; ─────────────────────────────────────────────────
@emit_header:
  ;;; magic
  MOV     R0, 0x534F4D41
  CALL    @emit_u32
  ;;; version
  MOV     R0, 0x00010000
  CALL    @emit_u32
  ;;; arch (ANY=0), som rows, som cols, max agents
  MOV     R0, 0x00
  CALL    @emit_u8
  MOV     R0, 0x10             ;;; 16 rows
  CALL    @emit_u8
  MOV     R0, 0x10             ;;; 16 cols
  CALL    @emit_u8
  MOV     R0, 0x40             ;;; 64 agents
  CALL    @emit_u8
  ;;; offsets patched after pass 2
  MOV     R0, 0x00000020       ;;; code starts at byte 32
  CALL    @emit_u32
  MOV     R0, 0x00000000       ;;; code size (patched later)
  CALL    @emit_u32
  MOV     R0, 0x00000000       ;;; data offset (patched later)
  CALL    @emit_u32
  MOV     R0, 0x00000000       ;;; data size
  CALL    @emit_u32
  MOV     R0, 0x00000000       ;;; som offset
  CALL    @emit_u32
  MOV     R0, 0x0003           ;;; flags: SELF_MODIFYING | ONLINE_LEARN
  CALL    @emit_u16
  RET

;;; ─────────────────────────────────────────────────
;;; PASS ONE — label collection
;;; Scans source, records every @label: → sym table
;;; ─────────────────────────────────────────────────
@pass_one:
  MOV     R1, [src_len]

@pass_one_loop:
  CALL    @next_token
  JZ      R0, @pass_one_done    ;;; EOF

  ;;; check if token starts with '@'
  LOAD    R2, [tok_buf]
  MOV     R3, 0x40              ;;; '@' = 0x40
  JEQ     R2, R3, @record_label
  JMP     @pass_one_loop

@record_label:
  ;;; strip '@' and trailing ':' from tok_buf
  CALL    @strip_label_delims
  ;;; store in sym_names[sym_count], sym_addrs[sym_count] = bin_ptr
  MOV     R4, [sym_count]
  CALL    @sym_insert
  ADD     R4, R4, 0x01
  STORE   [sym_count], R4
  JMP     @pass_one_loop

@pass_one_done:
  RET

;;; ─────────────────────────────────────────────────
;;; PASS TWO — instruction encoding
;;; ─────────────────────────────────────────────────
@pass_two:

@pass_two_loop:
  CALL    @next_token
  JZ      R0, @pass_two_done

  ;;; Skip label definitions (already collected)
  LOAD    R2, [tok_buf]
  MOV     R3, 0x40
  JEQ     R2, R3, @pass_two_loop

  ;;; Skip comment lines
  MOV     R3, 0x3B              ;;; ';'
  JEQ     R2, R3, @skip_line

  ;;; Dispatch on mnemonic
  CALL    @encode_instr
  JNZ     R0, @pass_two_loop

  ;;; Unknown instruction
  CALL    @emit_error
  JMP     @pass_two_loop

@skip_line:
  CALL    @consume_line
  JMP     @pass_two_loop

@pass_two_done:
  RET

;;; ─────────────────────────────────────────────────
;;; ENCODE INSTRUCTION
;;; Matches mnemonic in tok_buf, reads operands,
;;; emits 8-byte instruction word
;;; ─────────────────────────────────────────────────
@encode_instr:
  ;;; Load mnemonic hash for fast dispatch
  CALL    @hash_token
  ;;; R1 = hash

  ;;; agent group
  MOV     R2, 0xA1B1          ;;; hash of "SPAWN"
  JEQ     R1, R2, @enc_SPAWN
  MOV     R2, 0xA2B2
  JEQ     R1, R2, @enc_AGENT_KILL
  MOV     R2, 0xA3B3
  JEQ     R1, R2, @enc_FORK
  MOV     R2, 0xA4B4
  JEQ     R1, R2, @enc_MERGE
  MOV     R2, 0xA5B5
  JEQ     R1, R2, @enc_BARRIER

  ;;; SOM group
  MOV     R2, 0xC1D1
  JEQ     R1, R2, @enc_SOM_BMU
  MOV     R2, 0xC2D2
  JEQ     R1, R2, @enc_SOM_TRAIN
  MOV     R2, 0xC3D3
  JEQ     R1, R2, @enc_WGHT_UPD
  MOV     R2, 0xC4D4
  JEQ     R1, R2, @enc_SOM_ELECT

  ;;; message group
  MOV     R2, 0xE1F1
  JEQ     R1, R2, @enc_MSG_SEND
  MOV     R2, 0xE2F2
  JEQ     R1, R2, @enc_MSG_RECV
  MOV     R2, 0xE3F3
  JEQ     R1, R2, @enc_BROADCAST

  ;;; flow group
  MOV     R2, 0xF1A1
  JEQ     R1, R2, @enc_JMP
  MOV     R2, 0xF2A2
  JEQ     R1, R2, @enc_JNZ
  MOV     R2, 0xF3A3
  JEQ     R1, R2, @enc_HALT
  MOV     R2, 0xF4A4
  JEQ     R1, R2, @enc_NOP
  MOV     R2, 0xF5A5
  JEQ     R1, R2, @enc_CALL
  MOV     R2, 0xF6A6
  JEQ     R1, R2, @enc_RET

  ;;; arith group
  MOV     R2, 0xB1C1
  JEQ     R1, R2, @enc_ADD
  MOV     R2, 0xB2C2
  JEQ     R1, R2, @enc_DOT
  MOV     R2, 0xB3C3
  JEQ     R1, R2, @enc_NORM

  MOV     R0, 0x00             ;;; unrecognized
  RET

;;; ─────────────────────────────────────────────────
;;; ENCODER STUBS — each reads operands & emits word
;;; ─────────────────────────────────────────────────

@enc_SPAWN:
  CALL    @read_areg           ;;; → R5 (agent reg)
  CALL    @read_label_ref      ;;; → R6 (label address or patch)
  CALL    @build_word
  ;;; opcode=0x01, agent=R5, som=0,0, reg=0, imm=R6
  MOV     R8, 0x01
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_SOM_TRAIN:
  CALL    @read_rreg           ;;; input vector reg → R5
  CALL    @read_rreg           ;;; lr reg → R6
  MOV     R8, 0x12
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_MSG_SEND:
  CALL    @read_areg           ;;; target agent → R5
  CALL    @read_operand        ;;; payload → R7
  MOV     R8, 0x20
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_HALT:
  MOV     R8, 0x37
  ZERO    R5
  ZERO    R6
  ZERO    R7
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_NOP:
  MOV     R8, 0x38
  ZERO    R5
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_AGENT_KILL:
  CALL    @read_areg
  MOV     R8, 0x02
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_FORK:
  CALL    @read_imm
  CALL    @read_label_ref
  MOV     R8, 0x03
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_MERGE:
  CALL    @read_rreg
  CALL    @read_rreg
  MOV     R8, 0x04
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_BARRIER:
  CALL    @read_imm
  MOV     R8, 0x05
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_SOM_BMU:
  CALL    @read_rreg
  CALL    @read_rreg
  MOV     R8, 0x11
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_WGHT_UPD:
  CALL    @read_rreg
  CALL    @read_rreg
  MOV     R8, 0x14
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_SOM_ELECT:
  CALL    @read_rreg
  MOV     R8, 0x19
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_MSG_RECV:
  CALL    @read_rreg
  MOV     R8, 0x21
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_BROADCAST:
  CALL    @read_operand
  MOV     R8, 0x23
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_JMP:
  CALL    @read_label_ref
  MOV     R8, 0x30
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_JNZ:
  CALL    @read_rreg
  CALL    @read_label_ref
  MOV     R8, 0x32
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_CALL:
  CALL    @read_label_ref
  MOV     R8, 0x35
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_RET:
  MOV     R8, 0x36
  ZERO    R5
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_ADD:
  CALL    @read_rreg
  CALL    @read_rreg
  CALL    @read_rreg
  MOV     R8, 0x50
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_DOT:
  CALL    @read_rreg
  CALL    @read_rreg
  CALL    @read_rreg
  MOV     R8, 0x54
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

@enc_NORM:
  CALL    @read_rreg
  CALL    @read_rreg
  MOV     R8, 0x55
  CALL    @emit_instr_word
  MOV     R0, 0x01
  RET

;;; ─────────────────────────────────────────────────
;;; EMIT INSTRUCTION WORD
;;; R8=opcode, R5=agent_id, SOM coord from S3,
;;; R6=reg_fields, R7=immediate
;;; Emits 8 bytes to bin_buf
;;; ─────────────────────────────────────────────────
@emit_instr_word:
  ;;; build 64-bit word
  ;;; [opcode:8][agent:8][som_x:8][som_y:8][reg:16][imm:16]
  SHL     R8, R8, 56
  SHL     R5, R5, 48
  MOV     R9, [S3]             ;;; cached SOM coord
  SHL     R9, R9, 32
  SHL     R6, R6, 16
  OR      R8, R8, R5
  OR      R8, R8, R9
  OR      R8, R8, R6
  OR      R8, R8, R7
  ;;; write 8 bytes to bin_buf[bin_ptr]
  MOV     R10, [bin_ptr]
  STORE   [bin_buf + R10], R8
  ADD     R10, R10, 0x08
  STORE   [bin_ptr], R10
  RET

;;; ─────────────────────────────────────────────────
;;; PATCH RESOLVE — fix all forward label references
;;; ─────────────────────────────────────────────────
@patch_resolve:
  ZERO    R0
  MOV     R1, [patch_count]

@patch_loop:
  JEQ     R0, R1, @patch_done
  ;;; look up patch_names[R0] in sym table → addr
  CALL    @sym_lookup          ;;; → R2
  ;;; write addr into bin_buf at patch_locs[R0]
  MOV     R3, [patch_locs + R0]
  STORE   [bin_buf + R3], R2
  ADD     R0, R0, 0x01
  JMP     @patch_loop

@patch_done:
  RET

;;; ─────────────────────────────────────────────────
;;; UTILITIES
;;; ─────────────────────────────────────────────────

@emit_u8:
  MOV     R10, [bin_ptr]
  STORE   [bin_buf + R10], R0
  ADD     R10, R10, 0x01
  STORE   [bin_ptr], R10
  RET

@emit_u16:
  MOV     R10, [bin_ptr]
  STORE   [bin_buf + R10], R0
  ADD     R10, R10, 0x02
  STORE   [bin_ptr], R10
  RET

@emit_u32:
  MOV     R10, [bin_ptr]
  STORE   [bin_buf + R10], R0
  ADD     R10, R10, 0x04
  STORE   [bin_ptr], R10
  RET

@next_token:
  ;;; skip whitespace, read next token into tok_buf
  ;;; returns R0=1 if token read, R0=0 if EOF
  TRAP    0x10
  RET

@consume_line:
  TRAP    0x11
  RET

@hash_token:
  ;;; djb2-style hash of tok_buf → R1
  TRAP    0x12
  RET

@read_areg:
  TRAP    0x13
  RET

@read_rreg:
  TRAP    0x14
  RET

@read_imm:
  TRAP    0x15
  RET

@read_label_ref:
  TRAP    0x16
  RET

@read_operand:
  TRAP    0x17
  RET

@sym_insert:
  TRAP    0x18
  RET

@sym_lookup:
  TRAP    0x19
  RET

@strip_label_delims:
  TRAP    0x1A
  RET

@build_word:
  TRAP    0x1B
  RET

@emit_error:
  TRAP    0xFF
  RET

@error_empty:
  MOV     R0, ERR_SYNTAX
  TRAP    0xFF
  HALT
