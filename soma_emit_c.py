#!/usr/bin/env python3
"""
soma_emit_c.py — SOMA → C transpiler
Emits a self-contained C program from a .sombin file.
Compile with: gcc -O3 -march=native -ffast-math -o prog prog.c -lm -lpthread

Key optimisations emitted:
  - All registers are flat float[8] arrays (no boxing, no dicts)
  - SOM weights are a contiguous float array (cache-friendly row-major)
  - All opcodes inlined as C macros
  - Agent threads use pthreads
  - JIT-equivalent: instruction dispatch is a computed goto switch
  - Hot SOM train loop emitted with restrict + SIMD-friendly layout
"""

import sys, os, struct, math

HEADER_SIZE = 32
MEM_FLAG    = 0x80000000
VEC_DIM     = 8

OPNAME = {
    0x01:'SPAWN',    0x02:'AGENT_KILL',0x03:'FORK',    0x04:'MERGE',
    0x05:'BARRIER',  0x06:'SPAWN_MAP', 0x07:'WAIT',
    0x11:'SOM_BMU',  0x12:'SOM_TRAIN', 0x13:'SOM_NBHD',0x14:'WGHT_UPD',
    0x19:'SOM_ELECT',0x1A:'SOM_MAP',   0x1B:'SOM_SENSE',0x1C:'SOM_INIT',
    0x1D:'SOM_WALK', 0x1E:'SOM_DIST',  0x1F:'LR_DECAY',
    0x20:'MSG_SEND', 0x21:'MSG_RECV',  0x23:'BROADCAST',0x24:'ACCUM',
    0x30:'JMP',      0x31:'JZ',        0x32:'JNZ',     0x33:'JEQ',
    0x34:'JGT',      0x35:'CALL',      0x36:'RET',     0x37:'HALT',
    0x38:'NOP',      0x40:'MOV',       0x41:'STORE',   0x42:'LOAD',
    0x43:'TRAP',     0x50:'ADD',       0x51:'SUB',     0x52:'MUL',
    0x53:'DIV',      0x54:'DOT',       0x55:'NORM',
}

def die(m): print(f"emit-c: {m}", file=sys.stderr); sys.exit(1)


def load(path):
    d = open(path,'rb').read()
    if d[:4] != b'SOMA': die(f"bad magic: {path}")
    rows = d[9] or 16; cols = d[10] or 16; agents = d[11] or 64
    co   = struct.unpack_from('>I',d,12)[0]
    cs   = struct.unpack_from('>I',d,16)[0]
    do_  = struct.unpack_from('>I',d,20)[0]
    ds   = struct.unpack_from('>I',d,24)[0]
    code = d[co:co+cs]
    rem  = len(code)%8; 
    if rem: code += bytes(8-rem)
    data = d[do_:do_+ds] if ds else b''
    return rows, cols, agents, code, data


def parse_data(data):
    """Returns list of (name, dtype, [float...]) and raw float payload bytes."""
    if not data: return [], b''
    off = 0
    (n,) = struct.unpack_from('>I', data, off); off += 4
    syms = []
    for _ in range(n):
        (nl,) = struct.unpack_from('>H', data, off); off += 2
        name  = data[off:off+nl].decode(); off += nl
        dt, po, cnt = struct.unpack_from('>BII', data, off); off += 9
        syms.append((name, dt, po, cnt))
    payload = data[off:]
    return syms, payload


def decode(code):
    instrs = []
    for i in range(0, len(code)-7, 8):
        raw = struct.unpack_from('>Q', code, i)[0]
        instrs.append((
            HEADER_SIZE + i,            # abs addr
            (raw>>56)&0xFF,             # op
            (raw>>48)&0xFF,             # agent
            (raw>>40)&0xFF,             # src
            (raw>>32)&0xFF,             # dst
            raw&0xFFFFFFFF              # imm
        ))
    return instrs


def emit(path):
    rows, cols, max_agents, code, data_bytes = load(path)
    syms, payload = parse_data(data_bytes)
    instrs = decode(code)

    # ── payload as C float array ─────────────────────────────────────
    payload_floats = []
    for i in range(0, len(payload)-3, 4):
        (v,) = struct.unpack_from('>f', payload, i)
        payload_floats.append(v)

    out = []
    w = out.append

    w('/* Auto-generated by soma_emit_c.py — DO NOT EDIT */')
    w('#include <stdio.h>')
    w('#include <stdlib.h>')
    w('#include <string.h>')
    w('#include <math.h>')
    w('#include <pthread.h>')
    w('#include <stdint.h>')
    w('#include <time.h>')
    w('')

    # ── constants ────────────────────────────────────────────────────
    w(f'#define SOM_ROWS    {rows}')
    w(f'#define SOM_COLS    {cols}')
    w(f'#define MAX_AGENTS  {max_agents}')
    w(f'#define VEC_DIM     {VEC_DIM}')
    w(f'#define N_INSTRS    {len(instrs)}')
    w(f'#define DATA_FLOATS {max(len(payload_floats),1)}')
    w('')

    # ── data payload ─────────────────────────────────────────────────
    w('/* Data section */')
    w(f'static float g_data[DATA_FLOATS] = {{')
    chunks = [payload_floats[i:i+8] for i in range(0,len(payload_floats),8)]
    for chunk in chunks:
        w('  ' + ', '.join(f'{float(v):.9g}f'.replace('f', 'f') if '.' in f'{float(v):.9g}' else f'{float(v):.1f}f' for v in chunk) + ',')
    w('};')
    w('')

    # ── SOM weight grid (contiguous, cache-friendly) ──────────────────
    w('/* SOM weight grid: [row][col][dim] — row-major */')
    w(f'static float g_som[SOM_ROWS][SOM_COLS][VEC_DIM];')
    w('static float g_lr   = 0.5f;')
    w('static float g_nbhd = 3.0f;')
    w('static pthread_mutex_t g_som_lock = PTHREAD_MUTEX_INITIALIZER;')
    w('static int64_t g_acc = 0;')
    w('static pthread_mutex_t g_acc_lock = PTHREAD_MUTEX_INITIALIZER;')
    w('')

    # ── SOM functions ─────────────────────────────────────────────────
    w('static void som_init_random(void) {')
    w('  for(int r=0;r<SOM_ROWS;r++)')
    w('    for(int c=0;c<SOM_COLS;c++)')
    w('      for(int k=0;k<VEC_DIM;k++)')
    w('        g_som[r][c][k]=(float)rand()/(float)RAND_MAX;')
    w('}')
    w('')
    w('static void som_bmu(const float* restrict v, int* br, int* bc) {')
    w('  float best=1e30f; *br=0; *bc=0;')
    w('  for(int r=0;r<SOM_ROWS;r++) {')
    w('    for(int c=0;c<SOM_COLS;c++) {')
    w('      float d=0.0f;')
    w('      const float* w=g_som[r][c];')
    w('      for(int k=0;k<VEC_DIM;k++) { float t=v[k]-w[k]; d+=t*t; }')
    w('      if(d<best){ best=d; *br=r; *bc=c; }')
    w('    }')
    w('  }')
    w('}')
    w('')
    w('static void som_train(const float* restrict v, int br, int bc) {')
    w('  float nbhd2 = 2.0f*g_nbhd*g_nbhd;')
    w('  pthread_mutex_lock(&g_som_lock);')
    w('  for(int r=0;r<SOM_ROWS;r++) {')
    w('    for(int c=0;c<SOM_COLS;c++) {')
    w('      float dr=(float)(r-br), dc=(float)(c-bc);')
    w('      float h=expf(-(dr*dr+dc*dc)/nbhd2);')
    w('      float* w=g_som[r][c];')
    w('      for(int k=0;k<VEC_DIM;k++) w[k]+=g_lr*h*(v[k]-w[k]);')
    w('    }')
    w('  }')
    w('  pthread_mutex_unlock(&g_som_lock);')
    w('}')
    w('')
    w('static float som_sense(int r, int c) {')
    w('  float s=0.0f;')
    w('  for(int k=0;k<VEC_DIM;k++) s+=g_som[r][c][k];')
    w('  return s/VEC_DIM;')
    w('}')
    w('')
    w('static void som_elect(int* br, int* bc) {')
    w('  float best=-1e30f; *br=0; *bc=0;')
    w('  for(int r=0;r<SOM_ROWS;r++)')
    w('    for(int c=0;c<SOM_COLS;c++) {')
    w('      float v=som_sense(r,c);')
    w('      if(v>best){ best=v; *br=r; *bc=c; }')
    w('    }')
    w('}')
    w('')
    w('static void som_walk_gradient(int r, int c, int* nr, int* nc) {')
    w('  float best=som_sense(r,c); *nr=r; *nc=c;')
    w('  int dr[]={-1,1,0,0}, dc[]={0,0,-1,1};')
    w('  for(int i=0;i<4;i++){')
    w('    int rr=r+dr[i], cc=c+dc[i];')
    w('    if(rr>=0&&rr<SOM_ROWS&&cc>=0&&cc<SOM_COLS){')
    w('      float v=som_sense(rr,cc);')
    w('      if(v>best){best=v;*nr=rr;*nc=cc;}')
    w('    }')
    w('  }')
    w('}')
    w('')

    # ── agent struct and messaging ─────────────────────────────────────
    w('#define MAX_INBOX 64')
    w('typedef struct {')
    w('  int      id;')
    w('  int      parent_id;')
    w('  float    R[32][VEC_DIM];    /* register file — R0..R31 */')
    w('  float    S[16];             /* SOM state regs */')
    w('  int      som_r, som_c;')
    w('  int      bmu_r, bmu_c;')
    w('  int      pc;                /* code offset */')
    w('  int      running;')
    w('  int64_t  call_stack[1024];')
    w('  int      call_depth;')
    w('  /* inbox */')
    w('  float    inbox[MAX_INBOX][VEC_DIM];')
    w('  int      inbox_head, inbox_tail;')
    w('  pthread_mutex_t inbox_lock;')
    w('  pthread_cond_t  inbox_cond;')
    w('  pthread_t thread;')
    w('  int       started;')
    w('} Agent;')
    w('')
    w(f'static Agent g_agents[{max(max_agents,64)}];')
    w('static Agent* g_main_agent = NULL;')
    w('static pthread_barrier_t g_barrier;')
    w('static int g_barrier_count = 0;')
    w('')
    w('static void agent_enqueue(Agent* a, const float* v) {')
    w('  pthread_mutex_lock(&a->inbox_lock);')
    w('  int next=(a->inbox_tail+1)%MAX_INBOX;')
    w('  if(next!=a->inbox_head){')
    w('    memcpy(a->inbox[a->inbox_tail],v,VEC_DIM*sizeof(float));')
    w('    a->inbox_tail=next;')
    w('    pthread_cond_signal(&a->inbox_cond);')
    w('  }')
    w('  pthread_mutex_unlock(&a->inbox_lock);')
    w('}')
    w('')
    w('static void agent_dequeue(Agent* a, float* out) {')
    w('  /* spin-wait with bounded retries for message */')
    w('  for(int _try=0;_try<3000;_try++) {')
    w('    pthread_mutex_lock(&a->inbox_lock);')
    w('    if(a->inbox_head!=a->inbox_tail){')
    w('      memcpy(out,a->inbox[a->inbox_head],VEC_DIM*sizeof(float));')
    w('      a->inbox_head=(a->inbox_head+1)%MAX_INBOX;')
    w('      pthread_mutex_unlock(&a->inbox_lock);')
    w('      return;')
    w('    }')
    w('    pthread_mutex_unlock(&a->inbox_lock);')
    w('    if(!a->running) break;')
    w('    struct timespec ts={0,1000000}; nanosleep(&ts,NULL);')
    w('  }')
    w('  memset(out,0,VEC_DIM*sizeof(float));')
    w('}')
    w('')
    w('static void broadcast_all(const float* v, int exclude) {')
    w(f'  for(int i=0;i<{max(max_agents,64)};i++)')
    w('    if(i!=exclude && g_agents[i].started && g_agents[i].running)')
    w('      agent_enqueue(&g_agents[i], v);')
    w('}')
    w('')

    # ── instruction table as C array ─────────────────────────────────
    w('/* Instruction table */')
    w('typedef struct { uint8_t op,ag,src,dst; uint32_t imm; } Instr;')
    w(f'static const Instr g_code[{len(instrs)}] = {{')
    for addr, op, ag, src, dst, imm in instrs:
        nm = OPNAME.get(op,'???')
        w(f'  {{0x{op:02x},0x{ag:02x},0x{src:02x},0x{dst:02x},0x{imm:08x}}}, /* {nm} @ 0x{addr:x} */')
    w('};')
    w('')

    # ── execution function ────────────────────────────────────────────
    w('static void* agent_run(void* arg) {')
    w('  Agent* a=(Agent*)arg;')
    w('  while(a->running && a->pc < N_INSTRS) {')
    w('    const Instr* I=&g_code[a->pc];')
    w('    uint8_t op=I->op, ag=I->ag, src=I->src, dst=I->dst;')
    w('    uint32_t imm=I->imm;')
    w('    int jumped=0;')
    w('')
    w('    switch(op) {')

    # ── opcode cases ──────────────────────────────────────────────────
    w('    case 0x01: /* SPAWN */')
    w('      if(ag<MAX_AGENTS && !g_agents[ag].started) {')
    w('        Agent* child=&g_agents[ag];')
    w('        child->id=ag; child->parent_id=a->id;')
    w('        child->pc=(imm-32)/8; child->running=1; child->started=1;')
    w('        pthread_mutex_init(&child->inbox_lock,NULL);')
    w('        pthread_cond_init(&child->inbox_cond,NULL);')
    w('        pthread_create(&child->thread,NULL,agent_run,child);')
    w('      } break;')

    w('    case 0x03: /* FORK */')
    w('      for(int i=0;i<src;i++) {')
    w('        if(i<MAX_AGENTS && !g_agents[i].started) {')
    w('          Agent* child=&g_agents[i];')
    w('          child->id=i; child->parent_id=a->id;')
    w('          child->pc=(imm-32)/8; child->running=1; child->started=1;')
    w('          pthread_mutex_init(&child->inbox_lock,NULL);')
    w('          pthread_cond_init(&child->inbox_cond,NULL);')
    w('          { pthread_attr_t attr; pthread_attr_init(&attr);')
    w('            pthread_attr_setstacksize(&attr, 4*1024*1024);')
    w('            pthread_create(&child->thread,&attr,agent_run,child);')
    w('            pthread_attr_destroy(&attr); }')
    w('        }')
    w('      } break;')

    w('    case 0x02: /* AGENT_KILL */')
    w('      if(imm==0xFF) { for(int i=0;i<MAX_AGENTS;i++) g_agents[i].running=0; }')
    w('      else if(imm==0xFE) { a->running=0; jumped=1; }')
    w('      else { g_agents[ag].running=0; }')
    w('      break;')

    w('    case 0x05: /* BARRIER */')
    w('      for(int i=0;i<MAX_AGENTS;i++)')
    w('        if(g_agents[i].started && g_agents[i].running==0 && g_agents[i].thread)')
    w('          pthread_join(g_agents[i].thread, NULL);')
    w('      /* spin-wait for running agents */')
    w('      { int done=0; while(!done) { done=1;')
    w('          for(int i=0;i<MAX_AGENTS;i++) if(g_agents[i].started && g_agents[i].running) done=0;')
    w('          if(!done) { struct timespec ts={0,1000000}; nanosleep(&ts,NULL); } } }')
    w('      break;')

    w('    case 0x07: /* WAIT */')
    w('      if(ag<MAX_AGENTS && g_agents[ag].started)')
    w('        pthread_join(g_agents[ag].thread,NULL);')
    w('      break;')

    w('    case 0x04: /* MERGE */')
    w('      { pthread_mutex_lock(&g_acc_lock);')
    w('        a->R[dst][0]=(float)g_acc/1000.0f;')
    w('        g_acc=0;')
    w('        pthread_mutex_unlock(&g_acc_lock); } break;')

    w('    case 0x1C: /* SOM_INIT */ som_init_random(); break;')
    w('    case 0x1A: /* SOM_MAP  */ a->som_r=(imm>>8)&0xFF; a->som_c=imm&0xFF; break;')
    w('    case 0x1D: /* SOM_WALK */ som_walk_gradient(a->som_r,a->som_c,&a->som_r,&a->som_c); break;')

    w('    case 0x11: /* SOM_BMU */')
    w('      som_bmu(a->R[src],&a->bmu_r,&a->bmu_c);')
    w('      a->R[dst][0]=(float)a->bmu_r; a->R[dst][1]=(float)a->bmu_c; break;')

    w('    case 0x12: /* SOM_TRAIN */ som_train(a->R[src],a->bmu_r,a->bmu_c); break;')
    w('    case 0x14: /* WGHT_UPD  */ som_train(a->R[src],a->bmu_r,a->bmu_c); break;')

    w('    case 0x1B: /* SOM_SENSE */')
    w('      a->R[dst][0]=som_sense(a->som_r,a->som_c); break;')

    w('    case 0x19: /* SOM_ELECT */')
    w('      { int br,bc; som_elect(&br,&bc);')
    w('        a->R[dst][0]=(float)br; a->R[dst][1]=(float)bc; } break;')

    w('    case 0x1F: /* LR_DECAY */ { float rate=(float)imm/1000.0f; g_lr*=(1.0f-rate); if(g_lr<0.001f)g_lr=0.001f; } break;')

    w('    case 0x20: /* MSG_SEND */')
    w('      { float* v=a->R[src];')
    w('        if(ag==0xFF) { if(a->parent_id>=0 && a->parent_id<MAX_AGENTS) agent_enqueue(&g_agents[a->parent_id],v); else if(g_main_agent) agent_enqueue(g_main_agent,v); }')
    w('        else if(ag==0xFE) agent_enqueue(a,v);')
    w('        else agent_enqueue(&g_agents[ag],v); } break;')

    w('    case 0x21: /* MSG_RECV */ agent_dequeue(a,a->R[dst]); break;')

    w('    case 0x23: /* BROADCAST */')
    w('      { float v[VEC_DIM]={(float)(int)imm};')
    w('        broadcast_all(v,a->id); } break;')

    w('    case 0x24: /* ACCUM */')
    w('      { int64_t sv=(int64_t)(a->R[src][0]*1000.0f);')
    w('        pthread_mutex_lock(&g_acc_lock); g_acc+=sv; pthread_mutex_unlock(&g_acc_lock);')
    w('        a->R[dst][0]=a->R[dst][0]+a->R[src][0]; } break;')

    # Jumps
    w('    case 0x30: /* JMP  */ a->pc=(imm-32)/8; jumped=1; break;')
    w('    case 0x31: /* JZ   */ if((int)a->R[src][0]==0){a->pc=(imm-32)/8;jumped=1;} break;')
    w('    case 0x32: /* JNZ  */ if((int)a->R[src][0]!=0){a->pc=(imm-32)/8;jumped=1;} break;')
    w('    case 0x33: /* JEQ  */ if((int)a->R[src][0]==(int)a->R[dst][0]){a->pc=(imm-32)/8;jumped=1;} break;')
    w('    case 0x34: /* JGT  */ if((int)a->R[src][0]>(int)a->R[dst][0]){a->pc=(imm-32)/8;jumped=1;} break;')
    w('    case 0x35: /* CALL */')
    w('      if(a->call_depth<1024){a->call_stack[a->call_depth++]=a->pc+1;')
    w('        a->pc=(imm-32)/8;jumped=1;} break;')
    w('    case 0x36: /* RET  */')
    w('      if(a->call_depth>0){a->pc=(int)a->call_stack[--a->call_depth];jumped=1;}')
    w('      else{a->running=0;jumped=1;} break;')
    w('    case 0x37: /* HALT */ a->running=0; jumped=1; break;')
    w('    case 0x38: /* NOP  */ break;')

    # MOV / STORE / LOAD
    w('    case 0x40: /* MOV */')
    w('      if(src) memcpy(a->R[dst],a->R[src],VEC_DIM*sizeof(float));')
    w('      else if(imm&0x80000000u) {')
    w('        int off=(imm&0x7fffffff)/4;')
    w('        for(int k=0;k<VEC_DIM&&off+k<DATA_FLOATS;k++) a->R[dst][k]=g_data[off+k];')
    w('      } else { memset(a->R[dst],0,VEC_DIM*sizeof(float)); a->R[dst][0]=(float)imm/1000.0f; }')
    w('      break;')
    w('    case 0x41: /* STORE */')
    w('      if(imm&0x80000000u) {')
    w('        int off=(imm&0x7fffffff)/4;')
    w('        for(int k=0;k<VEC_DIM&&off+k<DATA_FLOATS;k++) g_data[off+k]=a->R[src][k];')
    w('      } break;')
    w('    case 0x42: /* LOAD */')
    w('      { int off=(imm&0x7fffffff)/4;')
    w('        for(int k=0;k<VEC_DIM&&off+k<DATA_FLOATS;k++) a->R[dst][k]=g_data[off+k];')
    w('      } break;')

    w('    case 0x43: /* TRAP */ a->R[0][0]=0.0f; break; /* EOF stub */')

    # Arithmetic — vector operations
    w('    case 0x50: /* ADD */')
    w('      if(imm) { a->R[dst][0]=(float)((int)a->R[src][0]+(int)imm); }')
    w('      else { for(int k=0;k<VEC_DIM;k++) a->R[dst][k]=a->R[src][k]+a->R[dst][k]; } break;')
    w('    case 0x51: /* SUB */')
    w('      if(imm) { a->R[dst][0]=(float)((int)a->R[dst][0]-(int)a->R[src][0]-(int)imm); }')
    w('      else { for(int k=0;k<VEC_DIM;k++) a->R[dst][k]-=a->R[src][k]; } break;')
    w('    case 0x52: /* MUL */')
    w('      for(int k=0;k<VEC_DIM;k++) a->R[dst][k]*=a->R[src][k]; break;')
    w('    case 0x54: /* DOT */')
    w('      { float d=0; for(int k=0;k<VEC_DIM;k++) d+=a->R[dst][k]*a->R[src][k];')
    w('        memset(a->R[dst],0,VEC_DIM*sizeof(float)); a->R[dst][0]=d; } break;')
    w('    case 0x55: /* NORM */')
    w('      { float n=0; for(int k=0;k<VEC_DIM;k++) n+=a->R[dst][k]*a->R[dst][k];')
    w('        n=sqrtf(n); if(n>1e-9f) for(int k=0;k<VEC_DIM;k++) a->R[dst][k]/=n; } break;')

    w('    default: break;')
    w('    } /* switch */')
    w('    if(!jumped) a->pc++;')
    w('  } /* while */')
    w('  return NULL;')
    w('}')
    w('')

    # ── main ─────────────────────────────────────────────────────────
    w('int main(void) {')
    w('  srand(42);')
    w('  som_init_random();')
    w(f'  memset(g_agents,0,sizeof(g_agents));')
    w('  /* run main agent (id=0xFF) */')
    w(f'  Agent main_agent; memset(&main_agent,0,sizeof(main_agent));')
    w('  main_agent.id=0xFF; main_agent.parent_id=-1;')
    w('  main_agent.pc=0; main_agent.running=1; main_agent.started=1;')
    w('  pthread_mutex_init(&main_agent.inbox_lock,NULL);')
    w('  pthread_cond_init(&main_agent.inbox_cond,NULL);')
    w('  g_main_agent = &main_agent;')
    w('  agent_run(&main_agent);')
    w('  /* join any spawned threads */')
    w(f'  for(int i=0;i<MAX_AGENTS-1;i++)')
    w('    if(g_agents[i].started && g_agents[i].thread)')
    w('      pthread_join(g_agents[i].thread,NULL);')
    w('  /* print non-zero registers */')
    w('  int any=0;')
    w('  for(int r=0;r<32;r++) {')
    w('    float s=0; for(int k=0;k<VEC_DIM;k++) s+=fabsf(main_agent.R[r][k]);')
    w('    if(s>1e-9f) { if(!any){printf("Registers:\\n");any=1;}')
    w('      printf("  R%d = [",r);')
    w('      for(int k=0;k<VEC_DIM;k++) printf("%.4f%s",main_agent.R[r][k],k<VEC_DIM-1?",":"");')
    w('      printf("]\\n"); }')
    w('  }')
    w('  return 0;')
    w('}')

    return "\n".join(out)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: soma_emit_c.py <file.sombin>", file=sys.stderr); sys.exit(1)
    path = sys.argv[1]
    if not os.path.exists(path): die(f"not found: {path}")
    print(emit(path))
