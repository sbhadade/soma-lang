/* Auto-generated by soma_emit_c.py — DO NOT EDIT */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <pthread.h>
#include <stdint.h>
#include <time.h>

#define SOM_ROWS    4
#define SOM_COLS    4
#define MAX_AGENTS  2
#define VEC_DIM     8
#define N_INSTRS    13
#define DATA_FLOATS 9

/* Data section */
static float g_data[DATA_FLOATS] = {
  0.800000012f, 0.200000003f, 0.600000024f, 0.400000006f, 0.899999976f, 0.100000001f, 0.699999988f, 0.300000012f,
  0.0f,
};

/* SOM weight grid: [row][col][dim] — row-major */
static float g_som[SOM_ROWS][SOM_COLS][VEC_DIM];
static float g_lr   = 0.5f;
static float g_nbhd = 3.0f;
static pthread_mutex_t g_som_lock = PTHREAD_MUTEX_INITIALIZER;
static int64_t g_acc = 0;
static pthread_mutex_t g_acc_lock = PTHREAD_MUTEX_INITIALIZER;

static void som_init_random(void) {
  for(int r=0;r<SOM_ROWS;r++)
    for(int c=0;c<SOM_COLS;c++)
      for(int k=0;k<VEC_DIM;k++)
        g_som[r][c][k]=(float)rand()/(float)RAND_MAX;
}

static void som_bmu(const float* restrict v, int* br, int* bc) {
  float best=1e30f; *br=0; *bc=0;
  for(int r=0;r<SOM_ROWS;r++) {
    for(int c=0;c<SOM_COLS;c++) {
      float d=0.0f;
      const float* w=g_som[r][c];
      for(int k=0;k<VEC_DIM;k++) { float t=v[k]-w[k]; d+=t*t; }
      if(d<best){ best=d; *br=r; *bc=c; }
    }
  }
}

static void som_train(const float* restrict v, int br, int bc) {
  float nbhd2 = 2.0f*g_nbhd*g_nbhd;
  pthread_mutex_lock(&g_som_lock);
  for(int r=0;r<SOM_ROWS;r++) {
    for(int c=0;c<SOM_COLS;c++) {
      float dr=(float)(r-br), dc=(float)(c-bc);
      float h=expf(-(dr*dr+dc*dc)/nbhd2);
      float* w=g_som[r][c];
      for(int k=0;k<VEC_DIM;k++) w[k]+=g_lr*h*(v[k]-w[k]);
    }
  }
  pthread_mutex_unlock(&g_som_lock);
}

static float som_sense(int r, int c) {
  float s=0.0f;
  for(int k=0;k<VEC_DIM;k++) s+=g_som[r][c][k];
  return s/VEC_DIM;
}

static void som_elect(int* br, int* bc) {
  float best=-1e30f; *br=0; *bc=0;
  for(int r=0;r<SOM_ROWS;r++)
    for(int c=0;c<SOM_COLS;c++) {
      float v=som_sense(r,c);
      if(v>best){ best=v; *br=r; *bc=c; }
    }
}

static void som_walk_gradient(int r, int c, int* nr, int* nc) {
  float best=som_sense(r,c); *nr=r; *nc=c;
  int dr[]={-1,1,0,0}, dc[]={0,0,-1,1};
  for(int i=0;i<4;i++){
    int rr=r+dr[i], cc=c+dc[i];
    if(rr>=0&&rr<SOM_ROWS&&cc>=0&&cc<SOM_COLS){
      float v=som_sense(rr,cc);
      if(v>best){best=v;*nr=rr;*nc=cc;}
    }
  }
}

#define MAX_INBOX 64
typedef struct {
  int      id;
  int      parent_id;
  float    R[32][VEC_DIM];    /* register file — R0..R31 */
  float    S[16];             /* SOM state regs */
  int      som_r, som_c;
  int      bmu_r, bmu_c;
  int      pc;                /* code offset */
  int      running;
  int64_t  call_stack[1024];
  int      call_depth;
  /* inbox */
  float    inbox[MAX_INBOX][VEC_DIM];
  int      inbox_head, inbox_tail;
  pthread_mutex_t inbox_lock;
  pthread_cond_t  inbox_cond;
  pthread_t thread;
  int       started;
} Agent;

static Agent g_agents[64];
static Agent* g_main_agent = NULL;
static pthread_barrier_t g_barrier;
static int g_barrier_count = 0;

static void agent_enqueue(Agent* a, const float* v) {
  pthread_mutex_lock(&a->inbox_lock);
  int next=(a->inbox_tail+1)%MAX_INBOX;
  if(next!=a->inbox_head){
    memcpy(a->inbox[a->inbox_tail],v,VEC_DIM*sizeof(float));
    a->inbox_tail=next;
    pthread_cond_signal(&a->inbox_cond);
  }
  pthread_mutex_unlock(&a->inbox_lock);
}

static void agent_dequeue(Agent* a, float* out) {
  /* spin-wait with bounded retries for message */
  for(int _try=0;_try<3000;_try++) {
    pthread_mutex_lock(&a->inbox_lock);
    if(a->inbox_head!=a->inbox_tail){
      memcpy(out,a->inbox[a->inbox_head],VEC_DIM*sizeof(float));
      a->inbox_head=(a->inbox_head+1)%MAX_INBOX;
      pthread_mutex_unlock(&a->inbox_lock);
      return;
    }
    pthread_mutex_unlock(&a->inbox_lock);
    if(!a->running) break;
    struct timespec ts={0,1000000}; nanosleep(&ts,NULL);
  }
  memset(out,0,VEC_DIM*sizeof(float));
}

static void broadcast_all(const float* v, int exclude) {
  for(int i=0;i<64;i++)
    if(i!=exclude && g_agents[i].started && g_agents[i].running)
      agent_enqueue(&g_agents[i], v);
}

/* Instruction table */
typedef struct { uint8_t op,ag,src,dst; uint32_t imm; } Instr;
static const Instr g_code[13] = {
  {0x01,0x00,0x00,0x00,0x00000060}, /* SPAWN @ 0x20 */
  {0x1a,0x00,0x00,0x00,0x00000000}, /* SOM_MAP @ 0x28 */
  {0x40,0x00,0x00,0x00,0x80000000}, /* MOV @ 0x30 */
  {0x20,0x00,0x00,0x00,0x00000000}, /* MSG_SEND @ 0x38 */
  {0x07,0x00,0x00,0x00,0x00000000}, /* WAIT @ 0x40 */
  {0x21,0x00,0x00,0x01,0x00000000}, /* MSG_RECV @ 0x48 */
  {0x41,0x00,0x01,0x00,0x80000020}, /* STORE @ 0x50 */
  {0x37,0x00,0x00,0x00,0x00000000}, /* HALT @ 0x58 */
  {0x21,0x00,0x00,0x00,0x00000000}, /* MSG_RECV @ 0x60 */
  {0x12,0x00,0x00,0x00,0x00000000}, /* SOM_TRAIN @ 0x68 */
  {0x1b,0x00,0x00,0x01,0x00000000}, /* SOM_SENSE @ 0x70 */
  {0x20,0xff,0x01,0x00,0x00000000}, /* MSG_SEND @ 0x78 */
  {0x02,0x00,0x00,0x00,0x000000fe}, /* AGENT_KILL @ 0x80 */
};

static void* agent_run(void* arg) {
  Agent* a=(Agent*)arg;
  while(a->running && a->pc < N_INSTRS) {
    const Instr* I=&g_code[a->pc];
    uint8_t op=I->op, ag=I->ag, src=I->src, dst=I->dst;
    uint32_t imm=I->imm;
    int jumped=0;

    switch(op) {
    case 0x01: /* SPAWN */
      if(ag<MAX_AGENTS && !g_agents[ag].started) {
        Agent* child=&g_agents[ag];
        child->id=ag; child->parent_id=a->id;
        child->pc=(imm-32)/8; child->running=1; child->started=1;
        pthread_mutex_init(&child->inbox_lock,NULL);
        pthread_cond_init(&child->inbox_cond,NULL);
        pthread_create(&child->thread,NULL,agent_run,child);
      } break;
    case 0x03: /* FORK */
      for(int i=0;i<src;i++) {
        if(i<MAX_AGENTS && !g_agents[i].started) {
          Agent* child=&g_agents[i];
          child->id=i; child->parent_id=a->id;
          child->pc=(imm-32)/8; child->running=1; child->started=1;
          pthread_mutex_init(&child->inbox_lock,NULL);
          pthread_cond_init(&child->inbox_cond,NULL);
          { pthread_attr_t attr; pthread_attr_init(&attr);
            pthread_attr_setstacksize(&attr, 4*1024*1024);
            pthread_create(&child->thread,&attr,agent_run,child);
            pthread_attr_destroy(&attr); }
        }
      } break;
    case 0x02: /* AGENT_KILL */
      if(imm==0xFF) { for(int i=0;i<MAX_AGENTS;i++) g_agents[i].running=0; }
      else if(imm==0xFE) { a->running=0; jumped=1; }
      else { g_agents[ag].running=0; }
      break;
    case 0x05: /* BARRIER */
      for(int i=0;i<MAX_AGENTS;i++)
        if(g_agents[i].started && g_agents[i].running==0 && g_agents[i].thread)
          pthread_join(g_agents[i].thread, NULL);
      /* spin-wait for running agents */
      { int done=0; while(!done) { done=1;
          for(int i=0;i<MAX_AGENTS;i++) if(g_agents[i].started && g_agents[i].running) done=0;
          if(!done) { struct timespec ts={0,1000000}; nanosleep(&ts,NULL); } } }
      break;
    case 0x07: /* WAIT */
      if(ag<MAX_AGENTS && g_agents[ag].started)
        pthread_join(g_agents[ag].thread,NULL);
      break;
    case 0x04: /* MERGE */
      { pthread_mutex_lock(&g_acc_lock);
        a->R[dst][0]=(float)g_acc/1000.0f;
        g_acc=0;
        pthread_mutex_unlock(&g_acc_lock); } break;
    case 0x1C: /* SOM_INIT */ som_init_random(); break;
    case 0x1A: /* SOM_MAP  */ a->som_r=(imm>>8)&0xFF; a->som_c=imm&0xFF; break;
    case 0x1D: /* SOM_WALK */ som_walk_gradient(a->som_r,a->som_c,&a->som_r,&a->som_c); break;
    case 0x11: /* SOM_BMU */
      som_bmu(a->R[src],&a->bmu_r,&a->bmu_c);
      a->R[dst][0]=(float)a->bmu_r; a->R[dst][1]=(float)a->bmu_c; break;
    case 0x12: /* SOM_TRAIN */ som_train(a->R[src],a->bmu_r,a->bmu_c); break;
    case 0x14: /* WGHT_UPD  */ som_train(a->R[src],a->bmu_r,a->bmu_c); break;
    case 0x1B: /* SOM_SENSE */
      a->R[dst][0]=som_sense(a->som_r,a->som_c); break;
    case 0x19: /* SOM_ELECT */
      { int br,bc; som_elect(&br,&bc);
        a->R[dst][0]=(float)br; a->R[dst][1]=(float)bc; } break;
    case 0x1F: /* LR_DECAY */ { float rate=(float)imm/1000.0f; g_lr*=(1.0f-rate); if(g_lr<0.001f)g_lr=0.001f; } break;
    case 0x20: /* MSG_SEND */
      { float* v=a->R[src];
        if(ag==0xFF) { if(a->parent_id>=0 && a->parent_id<MAX_AGENTS) agent_enqueue(&g_agents[a->parent_id],v); else if(g_main_agent) agent_enqueue(g_main_agent,v); }
        else if(ag==0xFE) agent_enqueue(a,v);
        else agent_enqueue(&g_agents[ag],v); } break;
    case 0x21: /* MSG_RECV */ agent_dequeue(a,a->R[dst]); break;
    case 0x23: /* BROADCAST */
      { float v[VEC_DIM]={(float)(int)imm};
        broadcast_all(v,a->id); } break;
    case 0x24: /* ACCUM */
      { int64_t sv=(int64_t)(a->R[src][0]*1000.0f);
        pthread_mutex_lock(&g_acc_lock); g_acc+=sv; pthread_mutex_unlock(&g_acc_lock);
        a->R[dst][0]=a->R[dst][0]+a->R[src][0]; } break;
    case 0x30: /* JMP  */ a->pc=(imm-32)/8; jumped=1; break;
    case 0x31: /* JZ   */ if((int)a->R[src][0]==0){a->pc=(imm-32)/8;jumped=1;} break;
    case 0x32: /* JNZ  */ if((int)a->R[src][0]!=0){a->pc=(imm-32)/8;jumped=1;} break;
    case 0x33: /* JEQ  */ if((int)a->R[src][0]==(int)a->R[dst][0]){a->pc=(imm-32)/8;jumped=1;} break;
    case 0x34: /* JGT  */ if((int)a->R[src][0]>(int)a->R[dst][0]){a->pc=(imm-32)/8;jumped=1;} break;
    case 0x35: /* CALL */
      if(a->call_depth<1024){a->call_stack[a->call_depth++]=a->pc+1;
        a->pc=(imm-32)/8;jumped=1;} break;
    case 0x36: /* RET  */
      if(a->call_depth>0){a->pc=(int)a->call_stack[--a->call_depth];jumped=1;}
      else{a->running=0;jumped=1;} break;
    case 0x37: /* HALT */ a->running=0; jumped=1; break;
    case 0x38: /* NOP  */ break;
    case 0x40: /* MOV */
      if(src) memcpy(a->R[dst],a->R[src],VEC_DIM*sizeof(float));
      else if(imm&0x80000000u) {
        int off=(imm&0x7fffffff)/4;
        for(int k=0;k<VEC_DIM&&off+k<DATA_FLOATS;k++) a->R[dst][k]=g_data[off+k];
      } else { memset(a->R[dst],0,VEC_DIM*sizeof(float)); a->R[dst][0]=(float)imm/1000.0f; }
      break;
    case 0x41: /* STORE */
      if(imm&0x80000000u) {
        int off=(imm&0x7fffffff)/4;
        for(int k=0;k<VEC_DIM&&off+k<DATA_FLOATS;k++) g_data[off+k]=a->R[src][k];
      } break;
    case 0x42: /* LOAD */
      { int off=(imm&0x7fffffff)/4;
        for(int k=0;k<VEC_DIM&&off+k<DATA_FLOATS;k++) a->R[dst][k]=g_data[off+k];
      } break;
    case 0x43: /* TRAP */ a->R[0][0]=0.0f; break; /* EOF stub */
    case 0x50: /* ADD */
      if(imm) { a->R[dst][0]=(float)((int)a->R[src][0]+(int)imm); }
      else { for(int k=0;k<VEC_DIM;k++) a->R[dst][k]=a->R[src][k]+a->R[dst][k]; } break;
    case 0x51: /* SUB */
      if(imm) { a->R[dst][0]=(float)((int)a->R[dst][0]-(int)a->R[src][0]-(int)imm); }
      else { for(int k=0;k<VEC_DIM;k++) a->R[dst][k]-=a->R[src][k]; } break;
    case 0x52: /* MUL */
      for(int k=0;k<VEC_DIM;k++) a->R[dst][k]*=a->R[src][k]; break;
    case 0x54: /* DOT */
      { float d=0; for(int k=0;k<VEC_DIM;k++) d+=a->R[dst][k]*a->R[src][k];
        memset(a->R[dst],0,VEC_DIM*sizeof(float)); a->R[dst][0]=d; } break;
    case 0x55: /* NORM */
      { float n=0; for(int k=0;k<VEC_DIM;k++) n+=a->R[dst][k]*a->R[dst][k];
        n=sqrtf(n); if(n>1e-9f) for(int k=0;k<VEC_DIM;k++) a->R[dst][k]/=n; } break;
    default: break;
    } /* switch */
    if(!jumped) a->pc++;
  } /* while */
  return NULL;
}

int main(void) {
  srand(42);
  som_init_random();
  memset(g_agents,0,sizeof(g_agents));
  /* run main agent (id=0xFF) */
  Agent main_agent; memset(&main_agent,0,sizeof(main_agent));
  main_agent.id=0xFF; main_agent.parent_id=-1;
  main_agent.pc=0; main_agent.running=1; main_agent.started=1;
  pthread_mutex_init(&main_agent.inbox_lock,NULL);
  pthread_cond_init(&main_agent.inbox_cond,NULL);
  g_main_agent = &main_agent;
  agent_run(&main_agent);
  /* join any spawned threads */
  for(int i=0;i<MAX_AGENTS-1;i++)
    if(g_agents[i].started && g_agents[i].thread)
      pthread_join(g_agents[i].thread,NULL);
  /* print non-zero registers */
  int any=0;
  for(int r=0;r<32;r++) {
    float s=0; for(int k=0;k<VEC_DIM;k++) s+=fabsf(main_agent.R[r][k]);
    if(s>1e-9f) { if(!any){printf("Registers:\n");any=1;}
      printf("  R%d = [",r);
      for(int k=0;k<VEC_DIM;k++) printf("%.4f%s",main_agent.R[r][k],k<VEC_DIM-1?",":"");
      printf("]\n"); }
  }
  return 0;
}
